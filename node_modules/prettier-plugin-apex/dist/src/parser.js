"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint no-param-reassign: 0 */
const child_process_1 = __importStar(require("child_process"));
const path_1 = __importDefault(require("path"));
const util_1 = require("./util");
const constants_1 = require("./constants");
const MAX_BUFFER = 8192 * 8192;
function parseTextWithSpawn(text, anonymous) {
    let serializerBin = (0, util_1.getSerializerBinDirectory)();
    if (process.platform === "win32") {
        serializerBin = path_1.default.join(serializerBin, "apex-ast-serializer.bat");
    }
    else {
        serializerBin = path_1.default.join(serializerBin, "apex-ast-serializer");
    }
    const args = ["-f", "json", "-i"];
    if (anonymous) {
        args.push("-a");
    }
    const executionResult = (0, child_process_1.spawnSync)(serializerBin, args, {
        input: text,
        maxBuffer: MAX_BUFFER,
    });
    const executionError = executionResult.error;
    if (executionError) {
        throw executionError;
    }
    if (executionResult.status !== 0) {
        throw new Error(executionResult.stdout.toString());
    }
    return executionResult.stdout.toString();
}
function parseTextWithHttp(text, serverHost, serverPort, anonymous) {
    const httpClientLocation = path_1.default.join(__dirname, "http-client.js");
    const args = [
        httpClientLocation,
        "-a",
        serverHost,
        "-f",
        "json",
        "-p",
        serverPort.toString(),
    ];
    if (anonymous) {
        args.push("-n");
    }
    if (!process.argv[0]) {
        throw new Error("Failed to call http client");
    }
    const executionResult = child_process_1.default.spawnSync(process.argv[0], args, {
        input: text,
        maxBuffer: MAX_BUFFER,
    });
    if (executionResult.status) {
        const executionError = `Failed to connect to Apex parsing server\r\n${executionResult.stderr.toString()}`;
        throw new Error(executionError);
    }
    return executionResult.stdout.toString();
}
// jorje calls the location node differently for different types of nodes,
// so we use this method to abstract away that difference
function getNodeLocation(node) {
    if (node.loc) {
        return node.loc;
    }
    if (node.location) {
        return node.location;
    }
    return null;
}
// The serialized string given back contains references (to avoid circular references),
// which need to be resolved. This method recursively walks through the
// deserialized object and resolve those references.
function resolveAstReferences(node, referenceMap) {
    const nodeId = node["@id"];
    const nodeReference = node["@reference"];
    if (nodeId) {
        referenceMap[nodeId] = node;
    }
    if (nodeReference) {
        // If it has a reference attribute, that means it's a leaf node
        return referenceMap[nodeReference];
    }
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            node[key] = resolveAstReferences(node[key], referenceMap);
        }
    });
    return node;
}
function handleNodeSurroundedByCharacters(startCharacter, endCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, startCharacter, location.startIndex, commentNodes, 
        /* backwards */ true),
        endIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, endCharacter, location.startIndex, commentNodes, 
        /* backwards */ false) + 1,
    });
}
function handleNodeStartedWithCharacter(startCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, startCharacter, location.startIndex, commentNodes, 
        /* backwards */ true),
        endIndex: location.endIndex,
    });
}
function handleNodeEndedWithCharacter(endCharacter) {
    return (location, sourceCode, commentNodes) => ({
        startIndex: location.startIndex,
        endIndex: (0, util_1.findNextUncommentedCharacter)(sourceCode, endCharacter, location.endIndex, commentNodes, 
        /* backwards */ false) + 1,
    });
}
function handleAnonymousUnitLocation(_location, sourceCode) {
    return {
        startIndex: 0,
        endIndex: sourceCode.length,
    };
}
function handleMethodDeclarationLocation(location, sourceCode, commentNodes, node) {
    // This is a method declaration with a body, so we can safely use the identity
    // location.
    if (node.stmnt.value) {
        return location;
    }
    // This is a Method Declaration with no body, in which case we need to use the
    // position of the closing parenthesis for the input parameters, e.g:
    // void method();
    return handleNodeEndedWithCharacter(")")(location, sourceCode, commentNodes);
}
function handleAnnotationLocation(location, sourceCode, commentNodes, node) {
    // This is an annotation without parameters, so we only need to worry about
    // the starting character
    if (!node.parameters || node.parameters.length === 0) {
        return handleNodeStartedWithCharacter("@")(location, sourceCode, commentNodes);
    }
    // If not, we need to use the position of the closing parenthesis after the
    // parameters as well
    return handleNodeSurroundedByCharacters("@", ")")(location, sourceCode, commentNodes);
}
// We need to generate the location for a node differently based on the node
// type. This object holds a String => Function mapping in order to do that.
const locationGenerationHandler = {};
const identityFunction = (location) => location;
// Sometimes we need to delete a location node. For example, a WhereCompoundOp
// location does not make sense since it can appear in multiple places:
// SELECT Id FROM Account
// WHERE Name = 'Name'
// AND Name = 'Other Name' // <- this AND node here
// AND Name = 'Yet Another Name' <- this AND node here
// If we keep those locations, a comment might be duplicated since it is
// attached to one WhereCompoundOp, and that operator is printed multiple times.
const removeFunction = () => null;
locationGenerationHandler[constants_1.APEX_TYPES.QUERY] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.SEARCH] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FOR_INIT] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FOR_ENHANCED_CONTROL] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.TERNARY_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_CLASS_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_INTERFACE_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.INNER_ENUM_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.IF_ELSE_BLOCK] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.NAME_VALUE_PARAMETER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.BINARY_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.BOOLEAN_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.ASSIGNMENT_EXPRESSION] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.FIELD_MEMBER] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VALUE_WHEN] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.ELSE_WHEN] = identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_COMPOUND_OPERATOR] = removeFunction;
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATION_STATEMENT] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_COMPOUND_EXPRESSION] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.WHERE_OPERATION_EXPRESSION] =
    identityFunction;
locationGenerationHandler[constants_1.APEX_TYPES.SELECT_INNER_QUERY] =
    handleNodeSurroundedByCharacters("(", ")");
locationGenerationHandler[constants_1.APEX_TYPES.ANONYMOUS_BLOCK_UNIT] =
    handleAnonymousUnitLocation;
locationGenerationHandler[constants_1.APEX_TYPES.NESTED_EXPRESSION] =
    handleNodeSurroundedByCharacters("(", ")");
locationGenerationHandler[constants_1.APEX_TYPES.PROPERTY_MEMBER] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.SWITCH_STATEMENT] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_LIST_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_SET_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_MAP_LITERAL] =
    handleNodeEndedWithCharacter("}");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_STANDARD] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.VARIABLE_DECLARATIONS] =
    handleNodeEndedWithCharacter(";");
locationGenerationHandler[constants_1.APEX_TYPES.NEW_KEY_VALUE] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_CALL_EXPRESSION] =
    handleNodeEndedWithCharacter(")");
locationGenerationHandler[constants_1.APEX_TYPES.ANNOTATION] = handleAnnotationLocation;
locationGenerationHandler[constants_1.APEX_TYPES.METHOD_DECLARATION] =
    handleMethodDeclarationLocation;
/**
 * Generate and/or fix node locations, because jorje sometimes either provides
 * wrong location information or a node, or doesn't provide any information at
 * all.
 * We will fix it here by enforcing that a parent node start
 * index is always <= any child node start index, and a parent node end index
 * is always >= any child node end index.
 * @param node the node being visited.
 * @param sourceCode the entire source code.
 * @param commentNodes all the comment nodes.
 * @return the corrected node.
 */
function handleNodeLocation(node, sourceCode, commentNodes) {
    let currentLocation;
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            const location = handleNodeLocation(node[key], sourceCode, commentNodes);
            if (location && currentLocation) {
                if (currentLocation.startIndex > location.startIndex) {
                    currentLocation.startIndex = location.startIndex;
                }
                if (currentLocation.endIndex < location.endIndex) {
                    currentLocation.endIndex = location.endIndex;
                }
            }
            if (location && !currentLocation) {
                currentLocation = location;
            }
        }
    });
    const apexClass = node["@class"];
    let handlerFn;
    if (apexClass) {
        const separatorIndex = apexClass.indexOf("$");
        if (separatorIndex !== -1) {
            const parentClass = apexClass.substring(0, separatorIndex);
            if (parentClass in locationGenerationHandler) {
                handlerFn = locationGenerationHandler[parentClass];
            }
        }
        if (apexClass in locationGenerationHandler) {
            handlerFn = locationGenerationHandler[apexClass];
        }
    }
    if (handlerFn && currentLocation) {
        node.loc = handlerFn(currentLocation, sourceCode, commentNodes, node);
    }
    else if (handlerFn && node.loc) {
        node.loc = handlerFn(node.loc, sourceCode, commentNodes, node);
    }
    if (!node.loc) {
        delete node.loc;
    }
    if (node.loc && currentLocation) {
        if (node.loc.startIndex > currentLocation.startIndex) {
            node.loc.startIndex = currentLocation.startIndex;
        }
        else {
            currentLocation.startIndex = node.loc.startIndex;
        }
        if (node.loc.endIndex < currentLocation.endIndex) {
            node.loc.endIndex = currentLocation.endIndex;
        }
        else {
            currentLocation.endIndex = node.loc.endIndex;
        }
    }
    if (currentLocation) {
        return { ...currentLocation };
    }
    if (node.loc) {
        return {
            startIndex: node.loc.startIndex,
            endIndex: node.loc.endIndex,
        };
    }
    return null;
}
/**
 * Generate extra metadata (e.g. empty lines) for nodes.
 * This method is called recursively while visiting each node in the tree.
 *
 * @param node the node being visited
 * @param emptyLineLocations a list of lines that are empty in the source code
 * @param allowTrailingEmptyLine whether trailing empty line is allowed
 * for this node. This helps when dealing with statements that contain other
 * statements. For example, we turn this to `false` for the block statements
 * inside an IfElseBlock
 *
 */
function generateExtraMetadata(node, emptyLineLocations, allowTrailingEmptyLine) {
    const apexClass = node["@class"];
    let allowTrailingEmptyLineWithin;
    const isSpecialClass = constants_1.TRAILING_EMPTY_LINE_AFTER_LAST_NODE.includes(apexClass);
    const trailingEmptyLineAllowed = constants_1.ALLOW_TRAILING_EMPTY_LINE.includes(apexClass);
    if (isSpecialClass) {
        allowTrailingEmptyLineWithin = false;
    }
    else if (trailingEmptyLineAllowed) {
        allowTrailingEmptyLineWithin = true;
    }
    else {
        allowTrailingEmptyLineWithin = allowTrailingEmptyLine;
    }
    // #511 - If the user manually specify linebreaks in their original query,
    // we will use that as a heuristic to manually add hardlines to the result
    // query as well.
    if (apexClass === constants_1.APEX_TYPES.SEARCH || apexClass === constants_1.APEX_TYPES.QUERY) {
        node.forcedHardline = node.loc.startLine !== node.loc.endLine;
    }
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            if (Array.isArray(node)) {
                const keyInt = parseInt(key, 10);
                if (keyInt === node.length - 1) {
                    // @ts-expect-error ts-migrate(7015) FIXME: Element implicitly has an 'any' type because index... Remove this comment to see the full error message
                    node[key].isLastNodeInArray = true; // So that we don't apply trailing empty line after this node
                }
                else {
                    // Here we flag a node if its next sibling is on the same line.
                    // The reasoning is that for a block of code like this:
                    // ```
                    // Integer a = 1; Integer c = 2; Integer c = 3;
                    //
                    // Integer d = 4;
                    // ```
                    // We don't want a trailing empty line after `Integer a = 1;`
                    // so we need to mark it as a special node.
                    const currentChildNode = node[keyInt];
                    const nextChildNode = node[keyInt + 1];
                    if (nextChildNode &&
                        nextChildNode.loc &&
                        currentChildNode.loc &&
                        nextChildNode.loc.startLine === currentChildNode.loc.endLine) {
                        node[keyInt].isNextStatementOnSameLine = true;
                    }
                }
            }
            generateExtraMetadata(node[key], emptyLineLocations, allowTrailingEmptyLineWithin);
        }
    });
    const nodeLoc = getNodeLocation(node);
    if (apexClass &&
        nodeLoc &&
        allowTrailingEmptyLine &&
        !node.isLastNodeInArray &&
        !node.isNextStatementOnSameLine) {
        const nextLine = nodeLoc.endLine + 1;
        const nextEmptyLine = emptyLineLocations.indexOf(nextLine);
        if (trailingEmptyLineAllowed && nextEmptyLine !== -1) {
            node.trailingEmptyLine = true;
        }
    }
    return nodeLoc;
}
// For each node, the jorje compiler gives us its line and its index within
// that line; however we use this method to resolve that line index to a global
// index of that node within the source code. That allows us to use prettier
// utility methods.
function resolveLineIndexes(node, lineIndexes) {
    const nodeLoc = getNodeLocation(node);
    if (nodeLoc && !("startLine" in nodeLoc)) {
        // The location node that we manually generate do not contain startLine
        // information, so we will create them here.
        nodeLoc.startLine =
            lineIndexes.findIndex((index) => index > nodeLoc.startIndex) - 1;
    }
    if (nodeLoc && !("endLine" in nodeLoc)) {
        nodeLoc.endLine =
            lineIndexes.findIndex((index) => index > nodeLoc.endIndex) - 1;
        // Edge case: root node
        if (nodeLoc.endLine < 0) {
            nodeLoc.endLine = lineIndexes.length - 1;
        }
    }
    if (nodeLoc && !("column" in nodeLoc)) {
        const nodeStartLineIndex = lineIndexes[lineIndexes.findIndex((index) => index > nodeLoc.startIndex) - 1];
        if (nodeStartLineIndex !== undefined) {
            nodeLoc.column = nodeLoc.startIndex - nodeStartLineIndex;
        }
    }
    Object.keys(node).forEach((key) => {
        if (typeof node[key] === "object") {
            node[key] = resolveLineIndexes(node[key], lineIndexes);
        }
    });
    return node;
}
// Get a map of line number to the index of its first character
function getLineIndexes(sourceCode) {
    // First line always start with index 0
    const lineIndexes = [0, 0];
    let characterIndex = 0;
    let lineIndex = 2;
    while (characterIndex < sourceCode.length) {
        const eolIndex = sourceCode.indexOf("\n", characterIndex);
        if (eolIndex < 0) {
            break;
        }
        lineIndexes[lineIndex] =
            lineIndexes[lineIndex - 1] +
                sourceCode.substring(characterIndex, eolIndex).length +
                1;
        characterIndex = eolIndex + 1;
        lineIndex += 1;
    }
    return lineIndexes;
}
function getEmptyLineLocations(sourceCode) {
    const whiteSpaceRegEx = /^\s*$/;
    const lines = sourceCode.split("\n");
    return lines
        .map((line) => whiteSpaceRegEx.test(line))
        .reduce((accumulator, currentValue, currentIndex) => {
        if (currentValue) {
            accumulator.push(currentIndex + 1);
        }
        return accumulator;
    }, []);
}
function parse(sourceCode, _, options) {
    const lineIndexes = getLineIndexes(sourceCode);
    let serializedAst;
    if (options.apexStandaloneParser === "built-in") {
        serializedAst = parseTextWithHttp(sourceCode, options.apexStandaloneHost, options.apexStandalonePort, options.parser === "apex-anonymous");
    }
    else {
        serializedAst = parseTextWithSpawn(sourceCode, options.parser === "apex-anonymous");
    }
    if (serializedAst) {
        let ast = JSON.parse(serializedAst);
        if (ast[constants_1.APEX_TYPES.PARSER_OUTPUT] &&
            ast[constants_1.APEX_TYPES.PARSER_OUTPUT].parseErrors.length > 0) {
            const errors = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].parseErrors.map((err) => `${err.message}.`);
            throw new Error(errors.join("\r\n"));
        }
        const commentNodes = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].hiddenTokenMap
            .map((item) => item[1])
            .filter((node) => node["@class"] === constants_1.APEX_TYPES.BLOCK_COMMENT ||
            node["@class"] === constants_1.APEX_TYPES.INLINE_COMMENT);
        ast = resolveAstReferences(ast, {});
        handleNodeLocation(ast, sourceCode, commentNodes);
        ast = resolveLineIndexes(ast, lineIndexes);
        generateExtraMetadata(ast, getEmptyLineLocations(sourceCode), true);
        ast.comments = ast[constants_1.APEX_TYPES.PARSER_OUTPUT].hiddenTokenMap
            .map((token) => token[1])
            .filter((node) => node["@class"] === constants_1.APEX_TYPES.INLINE_COMMENT ||
            node["@class"] === constants_1.APEX_TYPES.BLOCK_COMMENT);
        return ast;
    }
    return {};
}
exports.default = parse;
